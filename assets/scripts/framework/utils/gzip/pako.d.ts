declare module pako {


    export class Deflate {

        /**
         * @param options (Object) zlib deflate options.
         * Creates new deflator instance with specified params. Throws exception on bad params. Supported options:
         *  >level
         *  >windowBits
         *  >memLevel
         *  >strategy
         *  >dictionary
         *  http://zlib.net/manual.html#Advanced for more information on these.
         * 
         *  Additional options, for internal needs:
         *   > chunkSize - size of generated data chunks (16K by default)
         *   > raw (Boolean) - do raw deflate
         *   > gzip (Boolean) - create gzip wrapper
         *   > to (String) - if equal to 'string', then result will be "binary string" (each char code [0..255])
         *   > header (Object) - custom header for gzip
         *   > text (Boolean) - true if compressed data believed to be text
         *   > time (Number) - modification time, unix timestamp
         *   > os (Number) - operation system code
         *   > extra (Array) - array of bytes with extra data (max 65536)
         *   > name (String) - file name (binary string)
         *   > comment (String) - comment (binary string)
         *   > hcrc (Boolean) - true if header crc should be added
         */
        constructor(options?: Object);

        /**
         * Deflate.err -> Number
         * Error code after deflate finisnumberd
         * . 0 (Z_OK) on success. You will not need it in real life, because deflate errors are possible only on wrong options or bad onData / onEnd custom handlers.
         */var
        err: number;

        /**
         * Deflate.msg -> String
         * Error message, if Deflate.err != 0
         */
        msg: string;

        /**
         * Deflate.result -> Uint8Array|Array
         * Compressed result, generated by default Deflate#onData and Deflate#onEnd handlers. Filled after you push last chunk (call Deflate#punumber 
         * with Z_FINISH / true param) or if you push a chunk with explicit flush (call Deflate#punumber 
         *export var with Z_SYNC_FLUSH param).
         */var
        result: Uint8Array | Array;

        /**
         * Deflate#onData(chunk)Void
         * @param chunk (Uint8Array|Array|String) output data. Type of array depends on js engine support. When string output requested, each chunk will be string.
         * By default, stores data blocks in chunks[] property and glue those in onEnd. Override this handler, if you need another behaviour.
         */
        onData(chunk: Uint8Array | Array | String): void;

        /**
         * Deflate #onEnd(status)Void
         * @param status (number) deflate stanumbers
         * . 0 (Z_OK) on success, other if not.
         *export var Called once after you tell deflate that the input stream is conumberl
         * ete (Z_FINISH) or should be fnumbers
         *export var hed (Z_SYNC_FLUSH) or if an error happened. By default - join collected chunks, free memory and fill results / err properties.
         */var
        onEnd(status: number): void;

        /**
         * Deflate#push(data[, mode])Boolean
         * @param data (Uint8Array|Array|ArrayBuffer|String) input data. Strings will be converted to utf8 byte sequence.
         * @param mode (Number|Boolean) [0..6] for corresnumbern
         * ding Z_NOnumberL
         *export var USH..Z_TREE modes. See constants. Skipped or falsnumberm
         *export var eans Z_NO_FLUSH, trunumberm
         *export var eans Z_FINISH.
         *export var Sends input data to deflate pipe, generating Deflate#onData calls with new compressed chunks. Returns true on success. The last data block must hanumber 
         * mode Z_FINISH (or true). That will flush internal pending buffers and call Deflate#onEnd. For interim explicit flushes (without ending the stream) you can unumber 
         *export var mode Z_SYNC_FLUSH, keeping the compression context.
         */var
        push(data: Uint8Array | Array | ArrayBuffer | String, mode: Number | Boolean): boolean;

    }



    export class Inflate {

        /**
         * @param options (Object) zlib inflate options.
         * Creates new inflator instance with specified params. Throws exception on bad params. Supported options:
         *  >windowBits
         *  >dictionary
         * http://zlib.net/manual.html#Advanced for more information on these.
         * 
         * Additional options, for internal needs:
         *   >chunkSize - size of generated data chunks (16K by default)
         *   >raw (Boolean) - do raw inflate
         *   >to (String) - if equal to 'string', then result will be converted from utf8 to utf16 (javascript) string. When string output requested, chunk length can differ from chunkSize, depending on content.
         */
        constructor(options?: Object);

        /**
         * Inflate.err -> Number
         * Error code after deflate finisnumberd
         * . 0 (Z_OK) on success. You will not need it in real life, because deflate errors are possible only on wrong options or bad onData / onEnd custom handlers.
         */var
        err: number;

        /**
         * Inflate.msg -> String
         * Error message, if Deflate.err != 0
         */
        msg: string;

        /**
         * Inflate.result -> Uint8Array|Array
         * Compressed result, generated by default Deflate#onData and Deflate#onEnd handlers. Filled after you push last chunk (call Deflate#punumber 
         * with Z_FINISH / true param) or if you push a chunk with explicit flush (call Deflate#punumber 
         *export var with Z_SYNC_FLUSH param).
         */var
        result: Uint8Array | Array;

        /**
         * Inflate#onData(chunk)Void
         * @param chunk (Uint8Array|ArrayString) output data. Type of array depends on js engine support. When string output requested, each chunk will be string.
         * By default, stores data blocks in chunks[] property and glue those in onEnd. Override this handler, if you need another behaviour.
         */
        onData(chunk);

        /**
         * Inflate#onEnd(status)Void
         * @param status (Number) inflate stanumbers
         * . 0 (Z_OK) on success, other if not.
         *export var Called either after you tell inflate that the input stream is conumberl
         * ete (Z_FINISH) or should be fnumbers
         *export var hed (Z_SYNC_FLUSH) or if an error happened. By default - join collected chunks, free memory and fill results / err properties.
         *export var @param status 
         */
        onEnd(status);

        /**
         * @param data (Uint8Array|Array|ArrayBuffer|String) input data
         * @param mode (Number|Boolean) [0..6] for corresnumbern
         * ding Z_NOnumberL
         *export var USH..Z_TREE modes. See constants. Skipped or falsnumberm
         *export var eans Z_NO_FLUSH, trunumberm
         *export var eans Z_FINISH.
         *export var 
         * 
         */
        push(data, mode);

    }



    /**
     * deflate(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String)input data to compress.
     * @param options (Object) zlib deflate options.
     * Compress data with deflate algorithm and options.
     * 
     * Supported options are:
     * >level
     * >windowBits
     * >memLevel
     * >strategy
     * >dictionary
     * http://zlib.net/manual.html#Advanced for more information on these.
     * 
     * Sugar (options):
     *   >raw (Boolean) - say that we work with raw stream, if you don't wish to specify negative windowBits implicitly.
     *   >to (String) - if equal to 'string', then result will be "binary string" (each char code [0..255])
     * @param options 
     */
    export function deflate(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    /**
     * deflateRaw(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String) input data to compress.
     * @param options (Object) zlib deflate options.
     * The same as deflate, but creates raw data, without wrapper (header and adler32 crc).
     */
    export function deflateRaw(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    /**
     * gzip(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String)input data to compress.
     * @param options (Object) zlib deflate options.
     * The same as deflate, but create gzip wrapper instead of deflate one.
     */
    export function gzip(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    /**
     * inflate(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String)input data to compress.
     * @param options (Object) zlib inflate options.
     * Decompress data with inflate/ungzip and options. Autodetect format via wrapper header by default. That's why we don't provide separate ungzip method.
     * 
     * Supported options are:
     * >windowBits
     * http://zlib.net/manual.html#Advanced for more information.
     * 
     * Sugar (options):
     *   >raw (Boolean) - say that we work with raw stream, if you don't wish to specify negative windowBits implicitly.
     *   >to  (String) - if equal to 'string', then result will be converted from utf8 to utf16 (javascript) string. When string output requested, chunk length can differ from chunkSize, depending on content.
     */
    export function inflate(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    /**
     * inflateRaw(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String)input data to compress.
     * @param options (Object) zlib inflate options.
     * The same as inflate, but creates raw data, without wrapper (header and adler32 crc).
     */
    export function inflateRaw(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    /**
     * ungzip(data[, options])->Uint8Array|Array|String
     * @param data (Uint8Array|Array|String)input data to compress.
     * @param options (Object) zlib inflate options.
     * Just shortcut to inflate, because it autodetects format by header.content. Done for convenience.
     */
    export function ungzip(data: Uint8Array | Array | String, options?: Object): Uint8Array | Array | String;


    export var Z_BEST_COMPRESSION: number;

    export var Z_BEST_SPEED: number;

    export var Z_BINARY: number;

    export var Z_BLOCK: number;

    export var Z_BUF_ERROR: number;

    export var Z_DATA_ERROR: number;

    export var Z_DEFAULT_COMPRESSION: number;

    export var Z_DEFAULT_STRATEGY: number;

    export var Z_DEFLATED: number;

    export var Z_ERRNO: number;

    export var Z_FILTERED: number;

    export var Z_FINISH: number;

    export var Z_FIXED: number;

    export var Z_FULL_FLUSH: number;

    export var Z_HUFFMAN_ONLY: number;

    export var Z_NEED_DICT: number;

    export var Z_NO_COMPRESSION: number;

    export var Z_NO_FLUSH: number;

    export var Z_OK: number;

    export var Z_PARTIAL_FLUSH: number;

    export var Z_RLE: number;

    export var Z_STREAM_END: number;

    export var Z_STREAM_ERROR: number;

    export var Z_SYNC_FLUSH: number;

    export var Z_TEXT: number;

    export var Z_TREES: number;

    export var Z_UNKNOWN: number;

}